generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  address       String   @unique
  farcasterFid  Int?     @unique
  farcasterName String?
  email         String?  @unique
  inviteCode    String   @unique @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Gift relations
  sentGifts     Gift[]      @relation("SentGifts")
  receivedGifts Gift[]      @relation("ReceivedGifts")
  giftClaims    GiftClaim[]

  // Packet relations
  createdPackets Packet[]      @relation("CreatedPackets")
  claimedPackets PacketClaim[] @relation("ClaimedPackets")

  // Invitation relations
  inviter             User?        @relation("Invitations", fields: [inviterId], references: [id])
  inviterId           String?
  invited             User[]       @relation("Invitations")
  invitations         Invitation[] @relation("Inviter")
  invitationsReceived Invitation[] @relation("Invitee")

  // Other relations
  notifications Notification[]
  achievements  UserAchievement[]

  @@index([address])
  @@index([farcasterFid])
  @@index([inviteCode])
  @@map("users")
}

model Invitation {
  id         String   @id @default(cuid())
  inviterId  String
  inviteeId  String
  inviter    User     @relation("Inviter", fields: [inviterId], references: [id])
  invitee    User     @relation("Invitee", fields: [inviteeId], references: [id])
  rewardPaid Boolean  @default(false)
  createdAt  DateTime @default(now())

  @@unique([inviterId, inviteeId])
  @@index([inviterId])
  @@index([inviteeId])
  @@map("invitations")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String
  title     String   @db.VarChar(200)
  content   String   @db.Text
  data      Json?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, read])
  @@index([createdAt])
  @@index([type])
  @@map("notifications")
}

model UserAchievement {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  code       String
  unlockedAt DateTime @default(now())
  metadata   Json?

  @@unique([userId, code])
  @@index([userId])
  @@index([code])
  @@map("user_achievements")
}

// ============================================
// DeGift Models
// ============================================

enum TokenType {
  ETH
  ERC20
  ERC721
  ERC1155
}

enum GiftStatus {
  PENDING // Gift created but not claimed
  CLAIMED // Gift has been claimed
  REFUNDED // Gift has been refunded to sender
  EXPIRED // Gift has expired
}

model Gift {
  id           String @id @default(cuid())
  giftId       String @unique // On-chain gift ID
  chainId      Int // Chain ID (11155111 for Sepolia)
  createTxHash String @unique // Transaction hash of gift creation

  // Participants
  senderId         String
  sender           User    @relation("SentGifts", fields: [senderId], references: [id])
  recipientAddress String // Recipient wallet address
  recipientId      String? // Optional: User ID if recipient is registered
  recipient        User?   @relation("ReceivedGifts", fields: [recipientId], references: [id])

  // Token Information
  tokenType TokenType // ETH, ERC20, ERC721, or ERC1155
  token     String // Token contract address (address(0) for ETH)
  tokenId   String    @default("0") // Token ID for NFTs, "0" for fungible tokens
  amount    String // Amount in wei/smallest unit (BigInt as string)

  // Token metadata snapshot (for display purposes)
  tokenSymbol   String? // e.g., "ETH", "USDC"
  tokenDecimals Int? // e.g., 18 for ETH
  tokenName     String? // e.g., "Ethereum", "USD Coin"
  tokenImage    String? // Token logo URL
  nftImage      String? // NFT image URL (for ERC721/ERC1155)
  nftName       String? // NFT name

  // Gift Details
  message String?    @db.VarChar(500) // Personal message/blessing
  status  GiftStatus @default(PENDING)

  // Timestamps
  createdAt DateTime @default(now()) // When gift was created
  expiresAt DateTime // When gift expires
  updatedAt DateTime @updatedAt // Last update time

  // Claim/Refund tracking
  claimTxHash  String?   @unique // Transaction hash when claimed
  claimedAt    DateTime? // When gift was claimed
  refundTxHash String?   @unique // Transaction hash when refunded
  refundedAt   DateTime? // When gift was refunded

  // Relations
  claims GiftClaim[]

  // Indexes for query performance
  @@index([giftId])
  @@index([senderId])
  @@index([recipientAddress])
  @@index([recipientId])
  @@index([status])
  @@index([tokenType])
  @@index([expiresAt])
  @@index([createdAt])
  @@index([chainId, giftId]) // Composite: multi-chain support
  @@index([senderId, status]) // Composite: sender's gifts by status
  @@index([recipientId, status]) // Composite: recipient's gifts by status
  @@index([status, expiresAt]) // Composite: expired gift cleanup
  @@map("gifts")
}

model GiftClaim {
  id        String   @id @default(cuid())
  giftId    String
  gift      Gift     @relation(fields: [giftId], references: [id], onDelete: Cascade)
  claimerId String
  claimer   User     @relation(fields: [claimerId], references: [id])
  amount    String // Amount claimed (same as gift amount)
  txHash    String   @unique // Claim transaction hash
  chainId   Int // Chain ID
  claimedAt DateTime @default(now()) // When claimed

  // Additional metadata
  gasUsed  String? // Gas used in wei
  gasPrice String? // Gas price in wei

  @@unique([giftId, claimerId]) // One claim per gift per user
  @@index([giftId])
  @@index([claimerId])
  @@index([claimedAt])
  @@index([txHash])
  @@index([chainId, txHash]) // Composite: multi-chain transaction lookup
  @@map("gift_claims")
}

// ============================================
// RedPacket Models
// ============================================

model Packet {
  id       String @id @default(cuid())
  packetId String @unique // bytes32 from contract
  txHash   String @unique // Transaction hash of packet creation
  chainId  Int    @default(11155111) // Chain ID (11155111 for Sepolia)

  // Creator
  creatorId String
  creator   User   @relation("CreatedPackets", fields: [creatorId], references: [id])

  // Token info
  token         String // ERC20 address or 0x0 for ETH
  tokenSymbol   String? // Token symbol (e.g., "USDC")
  tokenDecimals Int? // Token decimals (e.g., 6, 18)
  tokenName     String? // Token name (e.g., "USD Coin")

  // Packet config
  totalAmount String // BigInt as string (original total amount)
  count       Int // Total number of claims allowed
  isRandom    Boolean // Fixed or random amounts
  message     String? @db.VarChar(100) // Blessing message

  // Remaining (updated on each claim)
  remainingAmount String // BigInt as string (current remaining amount)
  remainingCount  Int // Current remaining claim count

  // VRF status
  vrfRequestId String? // Chainlink VRF request ID
  randomReady  Boolean @default(false) // PacketRandomReady event received

  // Timestamps
  expireTime DateTime // When packet expires
  refunded   Boolean  @default(false) // Whether packet was refunded
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  claims PacketClaim[]

  // Block tracking (for reorg handling)
  blockNumber BigInt? // Block number of creation transaction
  blockHash   String? // Block hash of creation transaction

  @@index([packetId])
  @@index([creatorId])
  @@index([expireTime])
  @@index([blockNumber])
  @@index([chainId, packetId]) // Composite: multi-chain support
  @@index([creatorId, createdAt]) // Composite: user's packets by time
  @@index([randomReady]) // For filtering packets waiting for VRF
  @@map("packets")
}

model PacketClaim {
  id        String   @id @default(cuid())
  packetId  String
  packet    Packet   @relation(fields: [packetId], references: [id], onDelete: Cascade)
  claimerId String
  claimer   User     @relation("ClaimedPackets", fields: [claimerId], references: [id])
  amount    String // BigInt as string (amount claimed)
  txHash    String   @unique // Claim transaction hash
  isBest    Boolean  @default(false) // 手气最佳 (best luck marker)
  claimedAt DateTime @default(now())

  // Block tracking (for reorg handling)
  blockNumber BigInt? // Block number of claim transaction
  blockHash   String? // Block hash of claim transaction

  @@unique([packetId, claimerId]) // One claim per packet per user
  @@index([packetId])
  @@index([claimerId])
  @@index([isBest])
  @@index([blockNumber])
  @@index([claimedAt])
  @@map("packet_claims")
}

// ============================================
// Socket.IO Security Models
// ============================================

model SocketSecurityEvent {
  id        String   @id @default(cuid())
  type      String // SecurityEventType enum
  userId    String?
  socketId  String
  ip        String
  userAgent String?
  details   Json? // Additional event details
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([type, createdAt])
  @@index([ip, createdAt])
  @@index([socketId])
  @@map("socket_security_events")
}
